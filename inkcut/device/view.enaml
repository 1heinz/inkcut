# -*- coding: utf-8 -*-
"""
Copyright (c) 2017, Jairus Martin.

Distributed under the terms of the GPL v3 License.

The full license is in the file LICENSE, distributed with this software.

Created on Dec 7, 2017

@author: jrm
"""
from enaml.layout.api import hbox, spacer, align
from enaml.widgets.api import (
    Form, CheckBox, Container, Label, ProgressBar, PushButton
)
from enamlx.widgets.api import DoubleSpinBox
from inkcut.core.api import Model, DockItem
from inkcut.core.utils import to_unit, load_icon
from inkcut.preview.plot_view import PlotView
from .plugin import DeviceConfig

enamldef ConfigView(Container):
    attr model: Model
    Label:
        text = "No configuration available."

enamldef DeviceConfigView(Container):
    attr model: DeviceConfig
    Form:
        Label:
            text = "Step time"
        DoubleSpinBox:
            minimum = 0
            value:= model.step_time

        Label:
            text = "Step size"
        DoubleSpinBox:
            value << to_unit(model.step_size, 'mm')
            value :: model.step_size = from_unit(change['value'],'mm')
            suffix << " "+'mm'
            minimum = 0.00001
            maximum = 99999.9

        Label:
            text = "Interpolate paths"
        CheckBox:
            checked := model.interpolate

# #: Time between each path command
# #: Time to wait between each step so we don't get
# #: way ahead of the cutter and fill up it's buffer
# step_time = Float(strict=False).tag(config=True)
#
# #: Distance between each command in user units
# #: this is effectively the resolution the software supplies
# step_size = Float(parse_unit('1mm'), strict=False).tag(config=True)
#
# #: Interpolate paths breaking them into small sections that
# #: can be sent. This allows pausing mid plot as many devices do not have
# #: a cancel command.
# interpolate = Bool(True).tag(config=True)
#
# #: How often the position will be updated in ms. Low power devices should
# #: set this to a high number like 2000 or 3000
# sample_rate = Int(100).tag(config=True)
#
# #: In cm/s
# speed = Float(4, strict=False)
#
# #: Use absolute coordinates
# absolute = Bool().tag(config=True)


enamldef DeviceProgressDockItem(DockItem):
    title = "Live"
    name = "device-progress-item"
    icon = load_icon('printer')
    attr plugin
    attr preview << plugin.workbench.get_plugin('inkcut.preview').live_preview
    attr job_plugin << plugin.workbench.get_plugin('inkcut.job')
    attr device << plugin.device
    attr job << device.job
    Container:
        padding = 0
        PlotView: plot:
            minimum_size = (540,320)
            data := preview.plot
            axis_scales << {
                'left': to_unit(1, preview.units),
                'bottom': to_unit(1, preview.units)
            }
            Label: lbl:
                text << 'Position (x=%0.3f x y=%0.3f z=%s)'%(
                    device.position[0],
                    device.position[1],
                    device.position[2] and 'down' or 'up')
        Container:
            constraints = [
                hbox(prog, pb1,pb2),
                align('v_center', prog, pb1,pb2),
            ]
            ProgressBar: prog:
                value << int(job.info.progress) if job else 0
                text_visible = True
            PushButton: pb1:
                visible << device.busy
                text = "Abort"
                tool_tip = "Abort the current job"
                icon = load_icon('control_stop')
                clicked :: job.info.cancelled = True
            PushButton: pb2:
                text << "Resume" if (job and job.info.paused and not job.info.cancelled) else (
                    "Pause" if device.busy else "Start"
                )
                icon << load_icon('control_play' if ((job and job.info.paused)
                                    or not device.busy)
                                  else 'control_pause')
                clicked ::
                    if device.busy:
                        job.info.paused = not job.info.paused
                    elif job_plugin and job_plugin.job.document:
                        device.submit(job_plugin.job)

