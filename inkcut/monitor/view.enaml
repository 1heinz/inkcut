"""
Copyright (c) 2019, Jairus Martin.

Distributed under the terms of the GPL v3 License.

The full license is in the file LICENSE, distributed with this software.

Created on Feb 2, 2019

@author: jrm
"""
from enaml.widgets.api import  (
    Container, MultilineField, Field, PushButton, ObjectCombo
)
from enaml.layout.api import vbox, align, hbox
from enamlx.widgets.api import KeyEvent
from inkcut.core.api import DockItem
from inkcut.core.utils import load_icon


enamldef MonitorDockItem(DockItem):
    title = 'Monitor'
    name = 'monitor-item'
    icon = load_icon('keyboard')
    attr plugin
    attr device_plugin << plugin.workbench.get_plugin('inkcut.device')
    attr device << device_plugin.device
    attr connection << device.connection if device else None
    initialized ::
        # On startup observe the device connection's last output
        if connection:
            connection.observe('last_read', watch_output)
            connection.observe('last_write', watch_input)

    connection ::
        # When the device connection changes, cleanup, and observe the new last output
        old = change['oldvalue']
        new = change['value']
        if old:
            old.unobserve('last_read', watch_output)
            old.unobserve('last_write', watch_input)
        if new:
            new.observe('last_read', watch_output)
            new.observe('last_write', watch_output)

    func watch_output(change):
        if not plugin.output_enabled:
            return
        widget = comm_log.proxy.widget
        try:
            msg = change['value'].decode()
            widget.append(msg.strip() if plugin.strip_whitespace else msg)
            scroll_to_end()
        except:
            pass # Ignore decode errors

    func watch_input(change):
        if not plugin.input_enabled:
            return
        widget = comm_log.proxy.widget
        try:
            msg = change['value'].decode()
            widget.append(msg.strip() if plugin.strip_whitespace else msg)
            scroll_to_end()
        except:
            pass # Ignore decode errors

    func scroll_to_end():
        if not plugin.autoscroll:
            return
        # Scroll to end
        widget = comm_log.proxy.widget
        scroll_bar = widget.verticalScrollBar()
        scroll_bar.setValue(scroll_bar.maximum())

    func send_text():
        if connection and connection.connected:
            #comm_log.proxy.widget.append("\r\n"+to_send.text)
            msg = to_send.text+"\r\n" if plugin.add_newline else to_send.text
            connection.write(msg)
            to_send.text = ""

    Container:
        padding = 0
        constraints = [
                vbox(hbox(cmb_conn, btn_open, btn_clear, btn_autoscroll),
                    comm_log,
                    hbox(to_send, btn_send)),
                align('v_center', cmb_conn, btn_open, btn_clear, btn_autoscroll),
                align('v_center', to_send, btn_send),
        ]

        ObjectCombo: cmb_conn:
            items << device_plugin.devices or [device] if device else []
            to_string << lambda d: "{} @ {} ({})".format(
                d.declaration.id,
                d.connection if d.connection else "",
                d.connection.protocol.declaration.name if d.connection and d.connection.protocol else ""
            )
            selected << device
            selected ::
                dev = change['value']
                if dev:
                    device_plugin.device = dev
        PushButton: btn_open:
            #text << "Close" if opened else "Open"
            icon << load_icon("disconnect" if connection and connection.connected else "connect")
            tool_tip << "Connected. Click to disconnect" if connection and connection.connected else "Disconnected. Click to Connect"
            clicked ::
                if connection and connection.connected:
                    device.disconnect()
                else:
                    device.connect()
        PushButton: btn_clear:
            icon = load_icon("bin")
            tool_tip = "Clear console"
            clicked :: comm_log.proxy.widget.clear()
        PushButton: btn_autoscroll:
            icon << load_icon("lock_open") if plugin.autoscroll else load_icon("lock")
            tool_tip = "Auto scroll"
            checkable = True
            checked := plugin.autoscroll
        MultilineField: comm_log:
            activated :: self.proxy.widget.setReadOnly(True)
        Field: to_send:
            enabled << bool(connection and connection.connected)
            placeholder << "Enter a command.." if enabled else "Disconnected... reconnect first."
            tool_tip = "Press Shift+Return to send"
            KeyEvent:
                keys = ['shift+return']
                released :: send_text()
        PushButton: btn_send:
            text = "Send"
            enabled << bool(connection and connection.connected)
            clicked :: send_text()
